---
import "../styles/style.css";

import logo from "../assets/logo-ts.webp";
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<!-- SEO Básico -->
		<title>Tandil Solution | Transformación Digital para PyMEs</title>
		<meta
			name="description"
			content="Agencia de desarrollo web y software en Tandil. Transformamos PyMEs con Web Apps, E-commerce, Sistemas de Turnos y Estrategia Digital a medida."
		/>
		<meta
			name="keywords"
			content="desarrollo web tandil, software a medida, pymes argentina, diseño web, e-commerce, automatización de turnos, transformación digital, apps moviles"
		/>
		<meta name="author" content="Tandil Solution" />
		<meta name="robots" content="index, follow" />
		<link rel="canonical" href="https://tandilsolution.com.ar" />

		<!-- Open Graph / Facebook / WhatsApp (Para compartir) -->
		<meta property="og:type" content="website" />
		<meta property="og:url" content="https://tandilsolution.com.ar" />
		<meta
			property="og:title"
			content="Tandil Solution | Innovación Digital desde las Sierras"
		/>
		<meta
			property="og:description"
			content="Llevá tu negocio al siguiente nivel. Soluciones robustas, seguras y escalables para PyMEs."
		/>
		<meta
			property="og:image"
			content="https://tandilsolution.com.ar/assets/og-image.jpg"
		/>
		<!-- Reemplazar con URL real de imagen -->
		<meta
			name="twitter:description"
			content="Desarrollo web, apps móviles y software personalizado para impulsar tu negocio."
		/>
		<meta
			name="twitter:image"
			content="https://tandilsolution.com/twitter-image.jpg"
		/>

		<!-- Favicon -->
		<link rel="icon" type="image/svg+xml" href={logo.src} />
		<link
			rel="apple-touch-icon"
			sizes="180x180"
			href={logo.src}
		/>
		<link
			rel="icon"
			type="image/png"
			sizes="32x32"
			href={logo.src}
		/>
		<!-- Favicon (Buenas prácticas) -->
		<link rel="icon" type="image/png" href={logo.src} />
		<meta name="theme-color" content="#050507" />

		<!-- Generator -->
		<meta name="generator" content={Astro.generator} />

		<!-- Google Fonts: Inter & Space Grotesk (Preconnect for performance) -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&family=Inter:wght@300;400;600&display=swap"
			rel="stylesheet"
		/>

		<!-- FontAwesome -->
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
			integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
			crossorigin="anonymous"
			referrerpolicy="no-referrer"
		/>

		<!-- Structured Data (JSON-LD) -->
		<script type="application/ld+json">
			{
				"@context": "https://schema.org",
				"@type": "Organization",
				"name": "Tandil Solution",
				"url": "https://tandilsolution.com",
				"logo": {logo.src},
				"description": "Soluciones tecnológicas para Pymes: desarrollo web, aplicaciones móviles y software a medida",
				"address": {
					"@type": "PostalAddress",
					"addressLocality": "Tandil",
					"addressRegion": "Buenos Aires",
					"addressCountry": "AR"
				},
				"contactPoint": {
					"@type": "ContactPoint",
					"contactType": "Ventas",
					"email": "hellotandilsolution@gmail.com"
				},
				"sameAs": [
					"https://www.linkedin.com/in/tandilsolution/",
					"https://www.instagram.com/tandil.solution/?hl=es-la",
					"https://www.facebook.com/profile.php?id=61578499182847"
				]
			}
		</script>
	</head>
</html><body>
	<div id="canvas-container"></div>
	<slot />
</body>

<style>
	html,
	body {
		margin: 0;
		padding: 0;
		width: 100%;
		height: 100%;
	}
</style>

<script>
	import * as THREE from "three";
	// --- 1. SCROLL REVEAL ANIMATION ---
	const revealElements = document.querySelectorAll(".reveal");

	const revealOnScroll = () => {
		const windowHeight = window.innerHeight;
		const elementVisible = 100;

		revealElements.forEach((reveal) => {
			const elementTop = reveal.getBoundingClientRect().top;
			if (elementTop < windowHeight - elementVisible) {
				reveal.classList.add("active");
			}
		});
	};

	window.addEventListener("scroll", revealOnScroll);
	// Trigger once on load
	revealOnScroll();

	// --- 2. NAVBAR GLASS EFFECT ON SCROLL ---
	const navbar = document.getElementById("navbar");
	if (navbar) {
		window.addEventListener("scroll", () => {
			if (window.scrollY > 50) {
				navbar.classList.add(
					"bg-black/80",
					"backdrop-blur-lg",
					"border-b",
					"border-white/10",
				);
			} else {
				navbar.classList.remove(
					"bg-black/80",
					"backdrop-blur-lg",
					"border-b",
					"border-white/10",
				);
			}
		});
	}

	const initBgParticles = () => {
		const container = document.getElementById("canvas-container");
		const scene = new THREE.Scene();
		scene.fog = new THREE.FogExp2(0x050507, 0.002);
		const camera = new THREE.PerspectiveCamera(
			75,
			window.innerWidth / window.innerHeight,
			0.1,
			1000,
		);
		camera.position.z = 30;
		const renderer = new THREE.WebGLRenderer({
			alpha: true,
			antialias: true,
		});
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		if (container) {
			container.appendChild(renderer.domElement);
		}

		const geometry = new THREE.BufferGeometry();
		const count = 2000;
		const posArray = new Float32Array(count * 3);
		for (let i = 0; i < count * 3; i++) {
			posArray[i] = (Math.random() - 0.5) * 100;
		}
		geometry.setAttribute(
			"position",
			new THREE.BufferAttribute(posArray, 3),
		);
		const material = new THREE.PointsMaterial({
			size: 0.15,
			color: 0x00f2ff,
			transparent: true,
			opacity: 0.8,
		});
		const particlesMesh = new THREE.Points(geometry, material);
		scene.add(particlesMesh);

		const geoGeometry = new THREE.IcosahedronGeometry(10, 1);
		const geoMaterial = new THREE.MeshBasicMaterial({
			color: 0xbd00ff,
			wireframe: true,
			transparent: true,
			opacity: 0.05,
		});
		const shape = new THREE.Mesh(geoGeometry, geoMaterial);
		scene.add(shape);

		let mouseX = 0;
		let mouseY = 0;
		document.addEventListener("mousemove", (event) => {
			mouseX = event.clientX;
			mouseY = event.clientY;
		});
		const clock = new THREE.Clock();

		const animate = () => {
			const elapsedTime = clock.getElapsedTime();
			particlesMesh.rotation.y = elapsedTime * 0.05;
			shape.rotation.x = elapsedTime * 0.1;
			shape.rotation.y = elapsedTime * 0.1;
			particlesMesh.rotation.x +=
				(mouseY * 0.00005 - particlesMesh.rotation.x) * 0.05;
			particlesMesh.rotation.y +=
				(mouseX * 0.00005 - particlesMesh.rotation.y) * 0.05;
			renderer.render(scene, camera);
			window.requestAnimationFrame(animate);
		};
		animate();
		window.addEventListener("resize", () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});
	};
	// --- 4. HOLOGRAPHIC GLOBE (Three.js 2 - The New Viz) ---
	const initHolographicGlobe = () => {
		const container = document.getElementById("globe-viz-container");
		if (!container) return;

		// Dimensions specifically for this container
		const width = container.offsetWidth;
		const height = container.offsetHeight;

		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(
			45,
			width / height,
			0.1,
			1000,
		);
		camera.position.z = 18;

		const renderer = new THREE.WebGLRenderer({
			alpha: true,
			antialias: true,
		});
		renderer.setSize(width, height);
		renderer.setPixelRatio(window.devicePixelRatio);
		container.appendChild(renderer.domElement);

		// Group to hold globe elements
		const globeGroup = new THREE.Group();
		scene.add(globeGroup);

		// 1. Core Sphere (Dark & blocking to hide back lines slightly)
		const coreGeo = new THREE.SphereGeometry(5, 32, 32);
		const coreMat = new THREE.MeshBasicMaterial({
			color: 0x050507,
			transparent: true,
			opacity: 0.9,
		});
		const core = new THREE.Mesh(coreGeo, coreMat);
		globeGroup.add(core);

		// 2. Wireframe Lattice (Purple structure)
		const wireGeo = new THREE.IcosahedronGeometry(5.1, 2);
		const wireMat = new THREE.MeshBasicMaterial({
			color: 0xbd00ff,
			wireframe: true,
			transparent: true,
			opacity: 0.15,
		});
		const wireSphere = new THREE.Mesh(wireGeo, wireMat);
		globeGroup.add(wireSphere);

		// 3. Data Points Sphere (Cyan dots)
		const pointsGeo = new THREE.SphereGeometry(5.2, 64, 64);
		// We want random points on surface, not a grid
		const count = 1500;
		const particlesGeo = new THREE.BufferGeometry();
		const posArray = new Float32Array(count * 3);

		for (let i = 0; i < count; i++) {
			// Spherical coordinates
			const phi = Math.acos(-1 + (2 * i) / count);
			const theta = Math.sqrt(count * Math.PI) * phi;

			const r = 5.2;
			posArray[i * 3] = r * Math.cos(theta) * Math.sin(phi);
			posArray[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
			posArray[i * 3 + 2] = r * Math.cos(phi);
		}

		particlesGeo.setAttribute(
			"position",
			new THREE.BufferAttribute(posArray, 3),
		);
		const particlesMat = new THREE.PointsMaterial({
			color: 0x00f2ff,
			size: 0.08,
			transparent: true,
			opacity: 0.8,
		});
		const pointsSphere = new THREE.Points(particlesGeo, particlesMat);
		globeGroup.add(pointsSphere);

		// 4. Orbital Ring (Tech feel)
		const ringGeo = new THREE.TorusGeometry(7, 0.02, 16, 100);
		const ringMat = new THREE.MeshBasicMaterial({
			color: 0x00f2ff,
			transparent: true,
			opacity: 0.3,
		});
		const ring = new THREE.Mesh(ringGeo, ringMat);
		ring.rotation.x = Math.PI / 2;
		ring.rotation.y = Math.PI / 8;
		globeGroup.add(ring);

		// 5. Argentina Marker (The "Local" part)
		// Approx coords on sphere surface
		const markerGeo = new THREE.SphereGeometry(0.15, 16, 16);
		const markerMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White hot
		const marker = new THREE.Mesh(markerGeo, markerMat);

		// Adding a glow sprite for the marker could be complex, let's use a simple expanding ring mesh
		const pulseGeo = new THREE.RingGeometry(0.2, 0.25, 32);
		const pulseMat = new THREE.MeshBasicMaterial({
			color: 0x00f2ff,
			side: THREE.DoubleSide,
			transparent: true,
			opacity: 0.8,
		});
		const pulse = new THREE.Mesh(pulseGeo, pulseMat);
		marker.add(pulse);

		// Position marker (Static relative to globe group, rotates with it)
		// Just placing it arbitrarily on the surface to look good during rotation
		marker.position.set(3, -2, 3.5);
		pointsSphere.add(marker); // Attach to points sphere so it rotates with it

		// Animation
		const animate = () => {
			requestAnimationFrame(animate);

			// Rotate globe elements
			globeGroup.rotation.y += 0.002;

			// Counter-rotate wireframe slightly for complexity
			wireSphere.rotation.y -= 0.001;

			// Animate ring
			ring.rotation.z -= 0.005;

			// Pulse effect
			const scale = 1 + Math.sin(Date.now() * 0.005) * 0.5;
			pulse.scale.set(scale, scale, 1);
			pulse.material.opacity = 1 - (scale - 1);

			renderer.render(scene, camera);
		};

		animate();

		// Handle Resize
		window.addEventListener("resize", () => {
			// Must query container again in case layout changed
			const newWidth = container.offsetWidth;
			const newHeight = container.offsetHeight;
			camera.aspect = newWidth / newHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(newWidth, newHeight);
		});
	};

	// Initialize
	if (window.WebGLRenderingContext) {
		initBgParticles();
		initHolographicGlobe();
	}
</script>
